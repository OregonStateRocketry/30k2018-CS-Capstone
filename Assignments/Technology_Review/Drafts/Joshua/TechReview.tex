\documentclass[onecolumn, draftclsnofoot,10pt, compsoc]{IEEEtran}
\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}

\usepackage{geometry}
\geometry{textheight=9.5in, textwidth=7in}

% 1. Fill in these details
\def \CapstoneTeamName{30k CS Avionics}
\def \CapstoneTeamNumber{41}
\def \GroupMemberOne{Joshua Novak}
\def \GroupMemberTwo{Allison Sladek}
\def \GroupMemberThree{Levi Willmeth}
\def \CapstoneProjectName{30k Rocket Spaceport America}
\def \CapstoneSponsorCompany{Mechanical Engineering, Oregon State University}
\def \CapstoneSponsorPerson{Nancy Squires}

% 2. Uncomment the appropriate line below so that the document type works
\def \DocType{  %Problem Statement
				%Requirements Document
				Technology Review
				%Design Document
				%Progress Report
				}

\newcommand{\NameSigPair}[1]{\par
\makebox[2.75in][r]{#1} \hfil 	\makebox[3.25in]{\makebox[2.25in]{\hrulefill} \hfill		\makebox[.75in]{\hrulefill}}
\par\vspace{-12pt} \textit{\tiny\noindent
\makebox[2.75in]{} \hfil		\makebox[3.25in]{\makebox[2.25in][r]{Signature} \hfill	\makebox[.75in][r]{Date}}}}
% 3. If the document is not to be signed, uncomment the RENEWcommand below
%\renewcommand{\NameSigPair}[1]{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\begin{titlepage}
    \pagenumbering{gobble}
    \begin{singlespace}
    	\includegraphics[height=4cm]{coe_v_spot1}
        \hfill
        % 4. If you have a logo, use this includegraphics command to put it on the coversheet.
        %\includegraphics[height=4cm]{CompanyLogo}
        \par\vspace{.2in}
        \centering
        \scshape{
            \huge CS Capstone \DocType \par
            {\large\today}\par
            \vspace{.5in}
            \textbf{\Huge\CapstoneProjectName}\par
            \vfill
            {\large Prepared for}\par
            \Huge \CapstoneSponsorCompany\par
            \vspace{5pt}
            {\Large\NameSigPair{\CapstoneSponsorPerson}\par}
            {\large Prepared by }\par
            Group\CapstoneTeamNumber\par
            % 5. comment out the line below this one if you do not wish to name your team
            \CapstoneTeamName\par
            \vspace{5pt}
            {\Large
                \NameSigPair{\GroupMemberOne}\par
                \NameSigPair{\GroupMemberTwo}\par
                \NameSigPair{\GroupMemberThree}\par
            }
            \vspace{20pt}
        }
        \begin{abstract}
        % 6. Fill in your abstract
        	The document will explain the goal of our project.
					This includes and explanation of what the client has requested, our proposed solution, and a detailed description of what constitutes success on our part.
				\end{abstract}
    \end{singlespace}
\end{titlepage}
\newpage
\pagenumbering{arabic}
\tableofcontents
% 7. uncomment this (if applicable). Consider adding a page break.
%\listoffigures
%\listoftables
\clearpage

% 8. now you write!
\subsection{Potential Choices}
\subsubsection{Python}
Members of the team have used Python to create GUIs before, so the team is already aware of several libraries to use with this. Several are options are described in a blog on python libraries here (https://blog.modeanalytics.com/python-interactive-plot-libraries/) which also has links to the relvant libraries. They appear to be fairly easy to use and like they will fit our purposes, with some example plots being visually quite similar to our own end goal. Several of the libraries mentioned in the source have functions for outputting to HTML, so we should be able to use them to create our graphs. However, it is questionable whether this can be done live, though this should be possible by overwriting HTML files when a library does not have the functionality to dynamically update the graphs, which would accomplish the same goal. Most of these libraries will run on the server computer rather than the client, which is not the goal and may cause performance problems.

\subsubsection{JavaScript}
There are many libraries for JavaScript that the team should be able to use to generate or manipulate graphical content, including the CanvasJS library described here (https://canvasjs.com/docs/charts/how-to/live-updating-javascript-charts-json-api-ajax/). This library accomplishes most of our goals for graphing data, explicitly describes methods for live updates to graphs, and has methods for generating graphs from csv files. This library is extremely suitable to our tasks. JavaScript generally runs primarily on the client side, which is true of this library, so performance should not be an issue. The only potential issue will be the map, for which either another library can be used, or the map image can simply be edited using standard JavaScript methods to place red dots or other markers over the map at the correct locations.

\subsubsection{R}
R is specialized for mathematical programming, which suits our needs. There are libraries for R which generate graphs that fit the desired output, such as Plotly (https://plot.ly/r/). These libraries will either be able to perform live updates, or overwrite the currently existing html file to mimic this, though not optimally. Visually, the plots are very functional, and they include graphs that resemble the GPS map that needs to be created. However, it will need to run on the server rather than on the client computer, which may cause performance issues.

\subsection{Compare}
R (and the related libraries) has all of the graphs we will need and is specialized for much of this task, while also being very easy to use and code in. However, it will need to run on the server, and therefore may introduce performance issues. Python is not as specialized for this task or as easy to use, but is more flexible, and has a larger number of related libraries. It will also likely perform better. However, it also will run server side, and therefore may introduce performance issues. JavaScript has libraries that explicitly describe how to create live updates to dynamic graphs. It also runs client side, giving it the best performance. 

\subsection{Conclusion}
JavaScript is likely the best candidate. It will be able dynamically generate our graphs, and runs client side to deal with performance issues. As it is the only option that accomplishes all of these goals, it is what will be used to generate the GUI.

\section{Avionics Code - Language}
\subsection{Overview}
A portion of the Avionics code for the rocket and payload will be written by the CS team, with some of the code also being written by the ECE team in order to satisfy the requirements of their Senior Capstone. This code will need to run on a Blackberry Pi.
\subsection{Criteria}
The criteria for selecting the language of the Avionics code is based on three major factors, the efficiency of the language, the compatibility of the language with the devices that are likely to be used, and the suitability/usability of the language for accomplishing the required tasks. As a minimum requirement to be used at all, the code must be compatible with the Blackberry Pi, narrowing the range for selection. So far, the only device that is known to be used in the rocket is BigRedBee's BeeLine GPS, which will not heavily interact with the avionics code and does not appear to have a related library. Looking to previous years, most sensors have C libraries for interacting with them, so languages that are compatible with C functions or can call C programs are more valuable. Therefore the secondary criteria breaks down to the language's compatibility with C.

\subsection{Potential Choices}
\subsubsection{C}
C easily satisfies all three criteria. As a low-level language, C is highly efficient. This makes it excellent for criteria one. It is obviously compatible with itself, satisfying the second criteria. As for suitability/usability for the task, C is the standard language for embedded code such as avionics code. Issues may be encountered due to the difficulty of coding in C compared to higher level languages but these should be able to be addressed. When creating the test suite, a higher level language would normally be preferred due to the ease of use and the compatible libraries, but the test should still be able to be written in C.

\subsubsection{C++}
C++ is a high-level object-oriented language, making it inefficient in many cases. While C functions and avoiding the use of objects can address this problem, additional inefficiencies will be introduced by using C++. C functions can be used in C++, so there is unlikely to be any compatibility issues. All of the necessary code should be able to be written in C++ without significant issue, and it's status as a high-level language will make it easier to use. Test suites will be easier to create and organize with the option to use objects.

\subsubsection{Python}
Python is a high-level object-oriented language with particularly issues with efficiency. For this reason, it largely fails criteria one, and may cause performance issues. Python can call C programs and collect their outputs, so it should be able to satisfy criteria two with minimal effort. Finally, it should be very easy to write code and tests in Python, and there are a wealth of libraries that exist to bridge any gaps we may encounter. However, such libraries are likely to be unnecessary. Test cases will be relatively easy to write in python.

\subsection{Compare}
None of the three languages will have significant compatibility issues, though Python may encounter minor ones. Python is by far the most inefficient of the three languages, and only brings minor benefits in usability and suitability. C++ is significantly more efficient and has similar benefits to Python in usability and suitability, as we are unlikely to need to use third-party libraries that may exist for Python. Finally, C is vastly more efficient than either of the other options, and while it may be somewhat more difficult to use, it is not a significant downgrade in this case. 

\subsection{Conclusion}
C will be used for the avionics code due to the greater efficiency of the language with only minimal losses in usability and suitability. Tests may be written using C++, as the two languages are compatible with one another, but the avionics code itself will be written solely in C.


\section{Avionics Code - Testing Methods}
\subsection{Overview}
The client has requested that the CS team create a thorough suite of tests for the Avionics code. This is due to the many failed recoveries of rockets in the past, which may have been due to poorly written/tested code.
\subsection{Criteria}
The criteria for evaluation is whether the testing method will allow us to test against likely errors that we may encounter from the sensors. This will vary based on the sensor in question, but of particular importance is a sensor throwing a value that is outside of expectations, not an acceptable value, or failing to send a value at all. Of lesser but still significant importance is creating tests that ensure that the return values for a flight without sensor errors are accurate.
\subsection{Potential Choices}
\subsubsection{Real Data}
Testing against real data includes test launches/flights, testing against the sensors at rest, and testing against data recorded from previous flights, such as those carried out by earlier years or data found online. There are several limiting factors on these tests. Firstly, test launches/flights will not occur often, making their utility extremely limited. Also, we will most likely want our avionics code to be completely before any test launch. Second, previous flights and flights found online may have their data fixed to remove outliers or not contain errors. This makes this method less useful for satisfying our core criteria. However, they remain very useful for testing against the secondary criteria, as we should be able to test against flights/launches that reflect our own. Finally, tests against the sensors at rest will only be able to allow us to test within an extremely narrow range of possibilities that do not reflect the likely outcomes during a launch.
\subsubsection{Simulated Launch w/ Robustness}
Testing against a simulation tool or a collection of simulated data has a variety of advantages. It satisfies the second criteria very well, by testing against what should be the outputs of a typical launch or a launch within certain parameters. Robustness testing can be inserted in manner similar to how robustness testing is added to model-based testing, as outlined in this paper http://www.sciencedirect.com/science/article/pii/S1000936113001179. This robustness testing would include randomly having the sensor throw a value outside of the expected bound, a value that does not fit it's standard form, or having it shut down and turn on at random intervals. By setting this to occur randomly at some varying rate, the robustness of the suite can be dramatically increased, satisfying the second criteria.
\subsubsection{Unit Testing}
Unit Testing will ensure that the basic functionality of the code is there. It can be used to ensure that for very specific inputs the correct outputs are reached, and that every line of code and logic is checked. This helps satisfy the first and second criteria, and ensures the code is functional. It is also fairly straightforward to implement.
\subsection{Compare}
All three have particular advantages and disadvantages. Testing against real data is perhaps the best way to satisfy the second criteria, as it is definitely a test against a likely launch. However, it does not satisfy the first criteria to any significant degree, if at all. Unit Testing will assist in satisfying both criteria, but not as well as Simulated Launch with Robustness. However, it is much easier to implement than either other method.
\subsection{Conclusion}
Simulated Launch with Robustness is the best was to ensure that both criteria are satisfied, and therefore will be given the highest priority to complete. Unit Testing, due to the ease of implementing it as well as its significant returns, will be used alongside it. Testing against real data will be given the lowest priority, as it only satisfies the second criteria, and not significantly better than a Simulated Launch.
\end{document}
